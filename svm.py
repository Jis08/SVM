# -*- coding: utf-8 -*-
"""SVM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/110SAb9jy35d9U-MifNE6TEaNKdpLDZPX
"""

# Commented out IPython magic to ensure Python compatibility.
# Install missing modules if not already installed
!pip install -q sexmachine

# Import libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split, StratifiedKFold, GridSearchCV
from sklearn.metrics import accuracy_score, confusion_matrix, roc_curve, auc, classification_report
from sklearn.svm import SVC
import sexmachine.detector as gender

# Enable inline plotting
# %matplotlib inline

def read_datasets():
    """Reads user profiles from CSV files."""
    genuine_users = pd.read_csv("/content/users.csv")
    fake_users = pd.read_csv("/content/fusers.csv")
    x = pd.concat([genuine_users, fake_users])
    y = [0] * len(fake_users) + [1] * len(genuine_users)
    return x, y

def predict_sex(name):
    """Predicts the gender of a user based on their first name."""
    sex_predictor = gender.Detector(unknown_value="unknown", case_sensitive=False)
    first_name = name.str.split(" ").str[0]
    sex = first_name.apply(sex_predictor.get_gender)
    sex_dict = {"female": -2, "mostly_female": -1, "unknown": 0, "mostly_male": 1, "male": 2}
    return sex.map(sex_dict).fillna(0).astype(int)

def extract_features(x):
    """Extracts features for training."""
    lang_list = list(enumerate(np.unique(x['lang'])))
    lang_dict = {name: i for i, name in lang_list}
    x['lang_code'] = x['lang'].map(lambda val: lang_dict[val])
    x['sex_code'] = predict_sex(x['name'])

    feature_columns = ['statuses_count', 'followers_count', 'friends_count',
                       'favourites_count', 'listed_count', 'sex_code', 'lang_code']
    return x[feature_columns]

def plot_confusion_matrix(cm, title='Confusion Matrix', cmap=plt.cm.Blues):
    """Plots the confusion matrix."""
    target_names = ['Fake', 'Genuine']
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(target_names))
    plt.xticks(tick_marks, target_names, rotation=45)
    plt.yticks(tick_marks, target_names)
    plt.tight_layout()
    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.show()

def plot_roc_curve(y_test, y_pred):
    """Plots the ROC curve."""
    fpr, tpr, _ = roc_curve(y_test, y_pred)
    roc_auc = auc(fpr, tpr)
    plt.figure()
    plt.plot(fpr, tpr, color='blue', lw=2, label=f'AUC = {roc_auc:.2f}')
    plt.plot([0, 1], [0, 1], color='red', linestyle='--')
    plt.title('Receiver Operating Characteristic')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.legend(loc='lower right')
    plt.show()

def train_and_test(X_train, y_train, X_test):
    """Trains and predicts using an SVM classifier."""
    # Scale the features
    scaler = StandardScaler()
    X_train = scaler.fit_transform(X_train)
    X_test = scaler.transform(X_test)

    # Hyperparameter tuning
    param_grid = {
        'C': np.logspace(-2, 2, 5),
        'gamma': np.logspace(-2, 2, 5),
        'kernel': ['rbf']
    }
    cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
    grid_search = GridSearchCV(SVC(), param_grid, cv=cv, scoring='accuracy')
    grid_search.fit(X_train, y_train)

    print(f"Best Parameters: {grid_search.best_params_}")
    best_model = grid_search.best_estimator_

    # Train on the best model
    best_model.fit(X_train, y_train)
    y_pred = best_model.predict(X_test)
    return y_pred, best_model

def predict_sex(name):
    """Predicts the gender of a user based on their first name using a simple dictionary."""
    common_female_names = {'mary', 'jane', 'linda', 'patricia', 'barbara'}
    common_male_names = {'john', 'robert', 'michael', 'james', 'david'}

    first_name = name.str.split(" ").str[0].str.lower()

    def map_gender(fname):
        if fname in common_female_names:
            return -2
        elif fname in common_male_names:
            return 2
        else:
            return 0  # Unknown gender

    return first_name.map(map_gender).fillna(0).astype(int)

# Load datasets
print("Reading datasets...")
x, y = read_datasets()

# Extract features
print("Extracting features...")
x = extract_features(x)

# Split into training and testing sets
print("Splitting datasets into train and test sets...")
X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

# Train the model and make predictions
print("Training and testing...")
y_pred, model = train_and_test(X_train, y_train, X_test)

# Evaluate performance
print(f"Accuracy: {accuracy_score(y_test, y_pred):.2f}")
cm = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:")
print(cm)
plot_confusion_matrix(cm, title='Confusion Matrix')

# Normalized confusion matrix
cm_normalized = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
plot_confusion_matrix(cm_normalized, title='Normalized Confusion Matrix')

print("Classification Report:")
print(classification_report(y_test, y_pred, target_names=['Fake', 'Genuine']))

# Plot ROC curve
plot_roc_curve(y_test, y_pred)

# Example test data for a single user
user_data = pd.DataFrame({
    'name': ['SAK Nair'],
    'statuses_count': [656],
    'followers_count': [57],
    'friends_count': [693],
    'favourites_count': [597],
    'listed_count': [0],
    'lang': ['en'],  # Language is English ("en")
})


# Extract features
user_data_features = extract_features(user_data)

# Use the trained model to make predictions for this user
scaler = StandardScaler()
user_data_scaled = scaler.fit_transform(user_data_features)

# Predict using the best model
predicted_class = model.predict(user_data_scaled)

# Output the result
print(f"The user is predicted to be: {'Genuine' if predicted_class[0] == 1 else 'Fake'}")